# End-to-End Encryption (E2EE)

**End-to-End Encryption (E2EE)** in Noteece ensures that data is encrypted on the sender's device and only decrypted on the recipient's device. In our local-first, peer-to-peer context, "sender" and "recipient" are your own devices syncing with each other. No intermediary (like a relay server or cloud provider) ever sees the plaintext data or the decryption keys.

## 1. Cryptographic Primitives

Noteece uses standard, high-security algorithms provided by the Rust ecosystem (`RustCrypto` and `ring`). We do not roll our own crypto.

| Component                | Algorithm              | Purpose                           | Implementation Crate     |
| :----------------------- | :--------------------- | :-------------------------------- | :----------------------- |
| **Hashing**              | **Argon2id**           | Password hashing & Key Derivation | `argon2`                 |
| **Symmetric Encryption** | **XChaCha20-Poly1305** | Content & Payload Encryption      | `chacha20poly1305`       |
| **Key Exchange**         | **X25519 (ECDH)**      | Secure channel establishment      | `x25519-dalek`           |
| **Signatures**           | **Ed25519**            | Device identity & authentication  | `ed25519-dalek`          |
| **Database Encryption**  | **AES-256-CBC**        | SQLCipher Page-level encryption   | `rusqlite` + `sqlcipher` |

## 2. Key Hierarchy

To balance security and usability (password changes), Noteece uses a hierarchy of keys:

1.  **User Password:** The secret known only to the user.
2.  **Key Encryption Key (KEK):** Derived from the password.
    - _Algorithm:_ Argon2id
    - _Params:_ Memory=64MB, Iterations=3, Parallelism=1 (tunable).
    - _Salt:_ A random 16-byte salt stored in the database header.
3.  **Data Encryption Key (DEK):** The master key for the vault.
    - _Generation:_ 32 bytes of cryptographically secure random data (`OsRng`).
    - _Storage:_ The DEK is encrypted by the KEK and stored in the database metadata table (`vault_meta`).
    - _Usage:_ This key is used to encrypt note content and derived keys for other purposes.

**Why this hierarchy?**
If the user changes their password, we only need to re-encrypt the DEK with the new KEK. We _do not_ need to re-encrypt gigabytes of note data.

## 3. Data at Rest (Storage)

Noteece employs a "Defense in Depth" strategy for storage.

### Layer 1: Database Encryption (SQLCipher)

The entire SQLite database file is encrypted using SQLCipher.

- **Key:** A 256-bit key derived from the DEK (or a separate KEK path).
- **Scope:** Encrypts tables, indices, and metadata.
- **Effect:** If someone steals the `.db` file, they cannot open it with `sqlite3` without the key.

### Layer 2: Content Encryption (Application Level)

Sensitive fields (specifically `note.content`, `task.description`, `social_post.content`) are encrypted _before_ being sent to the database.

- **Algorithm:** XChaCha20-Poly1305.
- **Nonce:** A random 24-byte nonce is generated for every write.
- **Storage Format:** `[Nonce (24 bytes)] || [Ciphertext]`
- **Why?** This protects data even if the SQLCipher key is cached in memory and dumped, or if a bug exposes the database handle. It also allows us to sync encrypted blobs without decrypting them (blind sync).

## 4. Data in Transit (Sync)

When Device A syncs with Device B:

1.  **Transport Layer Security:**
    - We do not rely solely on TLS (HTTPS/WSS) because local IP connections might not have valid certificates.
    - Instead, we establish a **Noise-like** encrypted tunnel over the WebSocket.

2.  **Handshake (ECDH):**
    - Both devices generate ephemeral X25519 key pairs.
    - They exchange public keys.
    - They compute a shared secret (ECDH).
    - They verify identities using their long-term Ed25519 identity keys (established during Pairing).

3.  **Payload Encryption:**
    - All sync messages (`SyncPayload`) are encrypted with the session key derived from the ECDH secret.
    - The inner content (the note body) remains encrypted with the DEK (from Layer 2 above).
    - _Crucially:_ The receiving device must possess the DEK to read the note. This is shared securely during the initial "Pairing" phase.

## 5. Threat Model & Mitigations

| Threat                          | Mitigation                                                                                        |
| :------------------------------ | :------------------------------------------------------------------------------------------------ |
| **Stolen Device (Powered Off)** | Full Disk Encryption (OS) + SQLCipher + Argon2id makes brute-force infeasible.                    |
| **Stolen Device (Unlocked)**    | App-level lock (optional PIN) + Auto-lock timeout.                                                |
| **Malicious Network Peer**      | Authenticated Encryption (Poly1305) prevents tampering. Unknown peers are rejected (Mutual Auth). |
| **Compromised Relay Server**    | If we use a relay for internet sync, it sees only encrypted binary blobs. It has no keys.         |
| **Memory Dump**                 | Sensitive keys are zeroized (`Zeroize` trait) when dropped from memory.                           |

## 6. Key Rotation

_Current Status:_ Manual key rotation (re-encrypting the whole vault) is a planned feature. Password changes (rotating the KEK) are fully supported.

---

**References:**

- [SQLCipher Design](https://www.zetetic.net/sqlcipher/design/)
- [Argon2: The Memory-Hard Function](https://github.com/P-H-C/phc-winner-argon2)
